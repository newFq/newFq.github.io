<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[二叉树]]></title>
      <url>%2F2017%2F03%2F10%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[基本概念树是一种分层数据的抽象模型。现实生活中最常见的树的例子就是家谱、或是公司的组织构架图。在JS中也有类似的结构，比如DOM树。 相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了根节点）以及0个或者多个子节点。 下图为一个典型的二叉树结构图： 位于最顶层的节点叫做根节点，它没有父节点。 树中每个元素都叫做节点，节点分为内部节点和外部节点。 至少有一个子节点的节点称为内部节点。 没有子节点的节点称为外部节点或者叶节点。 一个节点可以有祖先和后代。 除了根节点，其它节点的祖先包括父节点、祖父节点、曾祖父节点。 一个节点的后代包括子节点、孙子节点、曾孙子节点。 树的结构中由节点和其后代组成的部分称为子树，如上图的13、12、14组成的结构。 节点具有属性： 深度：节点的深度取决于祖先节点的数量，例如途中节点3就有3个祖先节点，那么节点3的深度就是3。 高度：高度取决于树结构中节点的最大深度。 层级：一棵树也被分为层级，根节点在第0层，它的子节点在第1层，以此类推。 二叉树和二叉搜索树二叉树是树的一种，在二叉树中每个节点只有两个子节点：左侧节点和右侧节点。 二叉搜索树又是二叉树的一个子集，在二叉树的基础上，其左侧子节点只能储存比父节点小的值，而右侧子节点可以储存大于或者等于父节点的值。 理解这两个概念对于高效的向树中插入、查找和删除节点非常有帮助。 创建 BinarySearchTree 类BinarySearchTree类的构造函数非常简单，但是需要一个内部私有的方法用来创建新的子节点。 1234function BinarySearchTree()&#123; this.root = null; return this;&#125; 私有的创建新节点方法： 1234567BinarySearchTree.prototype._node = function(key)&#123; var node = &#123;&#125;; node.key = key; node.left = null; node.right = null; return node;&#125;; 在具体编写相关方法之前，先来通过图示理解下要完成的组织结构： 通过图示，可以发现树的结构和链表看起来非常相似，有异曲同工之妙。通过指针来表示节点之间的关系（术语称之为边）。对于树来说，其中一个细节是我们称每个节点为键，而不再是节点或者是项。在树中第一个节点不再是头节点，而是根节点。 接下来要实现的方法有： 名称 功能 insert(key) 向树中插入一个新键 search(key) 在树中查找一个键，返回：true/false inOrderTraverse 中序遍历所有节点 preOrderTraverse 先序遍历所有节点 postOrderTraverse 后序遍历所有节点 min 返回树中最小的值/键 max 返回树中最大的值/键 remove(key) 从树中移除某个键 向树中插入一个键要向树中插入一个新的节点，要经过三个步骤： 创建一个用来表示新节点的Node类实例，并且这个实例具有左右指针，默认指向null。 要验证这个插入操作是否为一种特殊情况。这个特殊情况就是这个节点是否为这个树的根节点。如果是就让根节点指向这个新节点。 如果将节点加入到树中的非根节点的位置，就需要判断需要加入到哪一层的哪个节点，以及是左侧还是右侧。 根据二叉搜索树的定义可以编写如下代码： 12345678910111213141516171819202122232425262728BinarySearchTree.prototype.insert = function(key)&#123; var node = this._node(key); if(this.root === null)&#123; this.root = node; &#125;else&#123; insertNode(this.root, node); &#125; function insertNode(root, node)&#123; // 如果新节点的键小于当前节点的键 if(node.key &lt; root.key)&#123; // 如果left为空直接插入 if(root.left === null)&#123; root.left = node; &#125;else&#123; // 否则就递归重新进行查找插入 insertNode(root.left, node); &#125; &#125;else&#123; // 如果大于等于则执行同样的逻辑 if(root.right === null)&#123; root.right = node; &#125;else&#123; insertNode(root.right, node); &#125; &#125; &#125; return this;&#125;; 下面来测试一下上面的方法： 123var tree = new BinarySearchTree(); tree.insert(11).insert(7).insert(15).insert(5).insert(3).insert(9).insert(8).insert(10).insert(13).insert(12).insert(14).insert(20).insert(18).insert(25); 上面将会创建如下结构的二叉树： 这个时候如果再插入一个值为6的键： 1tree.insert(6); 下面的步骤将会被执行： 树不是空的，insertNode()方法将会执行 算法会依次检测执行条件，直到有条件成立为止。 树的遍历遍历一棵树，是指访问树的没个节点并对它们进行某种操作的过程。访问一棵树的节点有三种方式：中序、先序、后序。 中序遍历中序遍历是一种上行访问BST节点的方式，也就是从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作，下面是其代码实现： 12345678910BinarySearchTree.prototype.inOrderTraverse = function (callback)&#123; (function inOrderTraverseNode(node, callback)&#123; if(node !== null)&#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125; &#125;)(this.root, callback); return this;&#125;; inOrderTraverse方法接收一个回掉函数作为参数，里面有一个inOrderTraverseNode辅助函数，接收的是一个节点和这个回掉函数，其中node !== null用来判断当前的节点是否存在，也就是递归停止的条件。 下面写一个辅助函数用来测试： 123function print(key)&#123; console.log(key);&#125; 测试如下： 1234567891011const tree = new BinarySearchTree();var data = [11, 7, 15, 5, 9, 3, 6, 8, 10, 13, 20, 12, 14, 18, 25];for (var i = 0; i &lt; data.length; i++) &#123; tree.insert(data[i]);&#125;console.log(tree);tree.inOrderTraverse(print) 结果如图： 上面的搜索过程如下图所示： 先序遍历先序遍历，是优先序后代节点的顺序访问没个节点的。先序遍历的一种应用是打印一个结构化的文档。其实现和中序遍历基本相同，只是回调函数的调用位置有所变化。 12345678910BinarySearchTree.prototype.preOrderTraverse = function (callback)&#123; (function preOrderTraverseNode(node, callback)&#123; if(node !== null)&#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125; &#125;)(this.root, callback); return this;&#125;; 测试代码： 1234567891011const tree = new BinarySearchTree();var data = [11, 7, 15, 5, 9, 3, 6, 8, 10, 13, 20, 12, 14, 18, 25];for (var i = 0; i &lt; data.length; i++) &#123; tree.insert(data[i]);&#125;console.log(tree);tree.preOrderTraverse(print) 结果如图： 上面代码的遍历顺序如下图所示： 后序遍历后序遍历则是先访问节点的后代节点，在访问节点自身。后序遍历的一种应用就是机选一个目录和它子目录中所有文件所占空间的大小。其实现依然和上面的类似，只是回调函数的位置不同： 12345678910BinarySearchTree.prototype.postOrderTraverse = function (callback)&#123; (function preOrderTraverseNode(node, callback)&#123; if(node !== null)&#123; preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125;)(this.root, callback); return this;&#125;; 测试代码： 1234567891011const tree = new BinarySearchTree();var data = [11, 7, 15, 5, 9, 3, 6, 8, 10, 13, 20, 12, 14, 18, 25];for (var i = 0; i &lt; data.length; i++) &#123; tree.insert(data[i]);&#125;console.log(tree);tree.postOrderTraverse(print) 结果如图： 遍历的顺序如下图所示： 搜索树中的值在树中，有三种经常执行的搜索类型： 最小值 最大值 特定的值 搜索最大值和最小值看看下面的树的结构图： 如果只用眼睛看这张图，你能一下找到最大键和最小键么？ 我相信你一定可以找的到。你会发现，最下面最左侧的节点就是最小键，最下面最右侧的节点就是最大键。知道这点，就可以很容易的写出对应的方法了。 查找最小键的方法： 12345678910BinarySearchTree.prototype.min = function ()&#123; return (function (node)&#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node.key; &#125; &#125;)(this.root);&#125;; 测试代码： 123456789const tree = new BinarySearchTree();var data = [11, 7, 15, 5, 9, 3, 6, 8, 10, 13, 20, 12, 14, 18, 25];for (var i = 0; i &lt; data.length; i++) &#123; tree.insert(data[i]);&#125;console.log(tree.min()); // 3 查找最大键的方法： 12345678910BinarySearchTree.prototype.max = function ()&#123; return (function (node)&#123; if(node)&#123; while(node &amp;&amp; node.right !== null)&#123; node = node.right; &#125; return node.key; &#125; &#125;)(this.root);&#125;; 测试代码： 1console.log(tree.max()); // 25 搜索特定的值判断某个键是否在当前的树中，即搜索树中特定的值操作，可以通过下面的代码实现： 12345678910111213BinarySearchTree.prototype.search = function (key)&#123; return (function search(node, key)&#123; if(node === null)&#123; return false; &#125;else if(key &lt; node.key)&#123; return search(node.left, key); &#125;else if(key &gt; node.key)&#123; return search(node.right, key); &#125;else&#123; return true; &#125; &#125;)(this.root, key);&#125;; 分析：如果传入键的key小于当前的跟节点，那么就意味着要在这个要查找的值在跟节点的左侧，反之亦然。直到找到不是null，不大于也不小于key的键，即是要查找的键。 测试代码： 12345678910const tree = new BinarySearchTree();var data = [11, 7, 15, 5, 9, 3, 6, 8, 10, 13, 20, 12, 14, 18, 25];for (var i = 0; i &lt; data.length; i++) &#123; tree.insert(data[i]);&#125;console.log(tree.search(5)); // trueconsole.log(tree.search(511)); // false 移除指定的键接下来要为BST实现下一个、也是最后一个方法：remove，这个方法也是最复杂的要给方法，先来看代码，稍后我会逐行解释： 1234567891011121314151617181920212223242526272829303132333435363738394041BinarySearchTree.prototype.remove = function (key)&#123; this.root = (function fn(node, key)&#123; if(node === null)&#123; return null; &#125; if(key &lt; node.key)&#123; node.left = fn(node.left, key); return node; &#125;else if(key &gt; node.key)&#123; node.right = fn(node.right, key); return node; &#125;else&#123; if(node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; if(node.left === null)&#123; node = node.right; return node; &#125; if(node.right === null)&#123; node = node.left; return node; &#125; var aux = _searchMin(node.right); node.key = aux.key; node.right = fn(node.right, aux.key); return node; &#125; &#125;)(this.root, key); function _searchMin(node)&#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node; &#125; return null; &#125;; return this;&#125;; 上面就是remove的代码了，可是说好了的解析呢？唉，自己看吧，要不我还得打好多字… 小结二叉树可能会有一侧边非常深，也就是说树的一条分支会有很多层，而其它分支只有几层，这样在遍历的时候就会存在一定的性能问题。如图： 于是发现学完了二叉树，还有各种各样的树…. 比如：有一种AVL树是一种自平衡的二叉树，意思是在任意一个节点左右两侧子树高度之差最多为1，也就是在添加或移除节点的时候会尽量试着成为一颗完整的树。除了AVL树还有红黑树可以进行高效的中序遍历操作，以及堆积树等。 不管都什么鸟树，在以后有时间的情况下，我会依次学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[散列表]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[基本概念散列表也就是HashTable类，也叫HashMap类，是Dictionary类的一种散列表实现方式。 散列算法的作用就是尽可能快地在数据结构中找到一个值。其中最简单的算法就是将每个键值中键的每个字母的ASCII值相加。 散列函数首先先来创建好HashTable的构造函数，这里将使用数组来表示： 1234function HashTable()&#123; this.table = []; return this;&#125; 在实现相关方法之前，先来创见一个简单的散列函数： 1234567HashTable.prototype.hashCode = function (key)&#123; var hash = 0; for(var i=0; i&lt;key.length; i++)&#123; hash += key.charCodeAt(i); &#125; return hash % 37;&#125; 上面的对37进行取余数，是随便填写的一个素数，目的是不会得到一个很大的数。 然后给这个类添加三个基础方法： 名称 功能 put(key, value) 向散列表增加(更新)一个新的项 remove(key) 根据键值从散列表中移除值 get(key) 返回根据键值索引到的特定的值 put() 方法12345HashTable.prototype.put = function(key, value)&#123; var index = this.hashCode(key); this.table[index] = value; return this;&#125;; get() 方法1234HashTable.prototype.get = function(key)&#123; var index = this.hashCode(key); return this.table[index];&#125;; remove() 方法123456HashTable.prototype.remove = function(key)&#123; var index = this.hashCode(key); var ret = this.table[index]; this.table[index] = undefined; return ret;&#125;; 测试： 1234567var hash = new HashTable(); hash.put(&apos;new&apos;, &apos;perfect&apos;).put(&apos;fq&apos;, &apos;best&apos;);console.log(hash);console.log(hash.get(&apos;new&apos;));console.log(hash.remove(&apos;type&apos;)); 处理冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称之为冲突(从hash % 37这句代码也可以看出来)。 测试下面的代码： 12345678910111213var hash = new HashTable();hash. put(&apos; Gandalf&apos;, &apos;gandalf@ email. com&apos;);hash. put(&apos; John&apos;, &apos;johnsnow@ email. com&apos;);hash. put(&apos; Tyrion&apos;, &apos;tyrion@ email. com&apos;);hash. put(&apos; Aaron&apos;, &apos;aaron@ email. com&apos;);hash. put(&apos; Donnie&apos;, &apos;donnie@ email. com&apos;);hash. put(&apos; Ana&apos;, &apos;ana@ email. com&apos;);hash. put(&apos; Jonathan&apos;, &apos;jonathan@ email. com&apos;);hash. put(&apos; Jamie&apos;, &apos;jamie@ email. com&apos;);hash. put(&apos; Sue&apos;, &apos;sue@ email. com&apos;);hash. put(&apos; Mindy&apos;, &apos;mindy@ email. com&apos;);hash. put(&apos; Paul&apos;, &apos;paul@ email. com&apos;);hash. put(&apos; Nathan&apos;, &apos;nathan@ email. com&apos;); 会得到如下结果： 很显然相同的key就会造成后面的覆盖前面的，使用数据结构丢失了数据很显然不是我们的目的。那么接下来就会介绍如何处理散列表冲突，常用的方法有：分离链接和线性探查法。 分离链接分离链接包括为散列表的每一个位置创建一个链表并将元素储存在里面。它是解决冲突最简单的方法，但是它在HashTable实例之外还需要额外的储存空间。 如果使用分离链接那么上面的案例输出的结果将是这个样子： 为了实现分离链接首先需要一个辅助方法将之前的key和value打包。 123456789HashTable.prototype.wrapValue = function(key, value)&#123; var obj = &#123;&#125;; obj.key = key; obj.value = value; obj.toString = function()&#123; return `$&#123;this.key&#125;:$&#123;this.value&#125;`; &#125;; return obj;&#125;; 接下来需要对之前的put、get等方法进行修改： 分离链接 put() 方法12345678HashTable.prototype.put = function(key, value)&#123; var index = this.hashCode(key); if(this.table[index] === undefined)&#123; this.table[index] = new Link(); &#125; this.table[index].append(this.wrapValue(key, value)); return this;&#125;; 分离链接 get() 方法123456789101112131415HashTable.prototype.get = function(key)&#123; var index = this.hashCode(key); if(this.table[index] !== undefined)&#123; var current = this.table[index].getHead(); while(current.next)&#123; if(current.element.key === key)&#123; return current.element.value; &#125; &#125; if(current.element.key === key)&#123; return current.element.value; &#125; &#125; return undefined;&#125;; 分离链接 remove() 方法1234567891011121314151617181920212223HashTable.prototype.remove = function(key)&#123; var index = this.hashCode(key); if(this.table[index] !== undefined)&#123; var current = this.table[index].getHead(); var ret = false; while(current.next)&#123; if(current.element.key === key)&#123; ret = this.table[index].remove(current.element); if(this.table[index].isEmpty())&#123; this.table[index] = undefined; &#125; &#125; current = current.next; &#125; if(current.element.key === key)&#123; ret = this.table[index].remove(current.element); if(this.table[index].isEmpty())&#123; this.table[index] = undefined; &#125; &#125; &#125; return ret;&#125;; 测试： 12345678var hash = new HashTable(); hash.put(&apos;new&apos;, &apos;perfect&apos;).put(&apos;Tyrion&apos;, &apos;best&apos;).put(&apos;Aaron&apos;, &apos;own&apos;);console.log(hash);console.log(hash.get(&apos;new&apos;));console.log(hash.remove(&apos;Aaron&apos;));console.log(hash.remove(&apos;new&apos;)); 线性探查线性探查就是当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index + 1的位置。如果index + 1的位置也被占据了，就尝试index + 2的位置，以此类推。 线性探查 put() 方法1234567891011121314HashTable.prototype.put = function(key, value)&#123; var index = this.hashCode(key); var value = this.wrapValue(key, value); if(this.table[index] === undefined)&#123; this.table[index] = value; &#125;else&#123; var position = ++index; while(this.table[position] !== undefined)&#123; position++; &#125; this.table[position] = value; &#125; return this;&#125;; 线性探查 get() 方法12345678910111213HashTable.prototype.get = function(key)&#123; var index = this.hashCode(key); if(!this.table[index]) return undefined; if(this.table[index].key === key)&#123; return this.table[index].value; &#125;else&#123; var position = ++index; while(this.table[position] === undefined || this.table[position].key !== key)&#123; position++; &#125; return this.table[position].value; &#125;&#125;; 线性探查 remove() 方法1234567891011121314151617HashTable.prototype.remove = function(key)&#123; var index = this.hashCode(key); var ret = false; if(!this.table[index]) return ret; if(this.table[index].key === key)&#123; ret = this.table[index]; this.table[index] = undefined; &#125;else&#123; var position = ++index; while(this.table[position] === undefined || this.table[position].key !== key)&#123; position++; &#125; ret = this.table[position].value; this.table[position] = undefined; &#125; return ret;&#125;; 测试： 12345678var hash = new HashTable(); hash.put(&apos;new&apos;, &apos;perfect&apos;).put(&apos;Tyrion&apos;, &apos;best&apos;).put(&apos;Aaron&apos;, &apos;own&apos;);console.log(hash);console.log(hash.get(&apos;12&apos;));console.log(hash.remove(&apos;Aaron&apos;));console.log(hash.get(&apos;Tyrion&apos;)); 优化散列函数由于之前的hashCode并不是一个很好的散列函数，会产生很多冲突。在网上有很多不同的实现方法，其中一个比较不错的叫做djb2，修改后代码如下： 1234567HashTable.prototype.hashCode = function (key)&#123; var hash = 5381; for(var i=0; i&lt;key.length; i++)&#123; hash = hash * 33 + key.charCodeAt(i); &#125; return hash % 1013;&#125; 上面的代码初始化一个hash变量并赋值为一个质数（大多数实现都使用5381），然后迭代参数key，将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加）。最后，我们将使用相加的和与另一个随机质数相除的余数。 使用这种算法在不去使用解决冲突的方案的情况下去测试之前的代码，会发现没有冲突，请自行查看结果，这里就不列出了。 小结在学完这一小部分知识之后，突然意识到数据结构的重要性，虽然个人只是单一的使用JS，但是数据结构可以帮助我更好的理解一些数据模型，在以后的编码中思维会更灵活。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字典]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%AD%97%E5%85%B8%2F</url>
      <content type="text"><![CDATA[基本概念在上一节中，我们学习了集合的基本概念，这一小节来看下字典的基本概念和使用。字典同样是用来存储不重复的值的数据结构。不同于集合的是，字典使用的是[键，值]的形式来储存数据的。两种数据结构实现的方式略有不同。 在ES6中，新增的Map类的数据结构，即我们说的字典。详细信息请查阅：ECMAScript6 Map 下面我们要实现的类就是以ES6中的Map类为基础的，你会发现它和Set类很相似。 基本结构要实现的Dictionary类的构造函数非常简单，如下： 1234function Dictionary()&#123; this.items = &#123;&#125;; return this;&#125; 基本方法要实现的功能如下： API 功能 add(key, value) 向字典中添加新元素 remove(key) 移除字典中对应的数据 has(key) 如果字典中包含key返回true否则false get(key) 通过key获取对应的value keys() 将字典中所有的键名以数组形式返回 values() 将字典中所有的数据值以数组形式返回 clear() 清空字典中的数据 size() 返回字典包含元素的数量 has() 方法先来实现这个has()方法，因为之后的方法会用到它。 123Dictionary.prototype.has = function (key)&#123; return this.items.hasOwnProperty(key);&#125;; add() 方法1234Dictionary.prototype.add = function (key, value)&#123; this.items[key] = value; return this;&#125;; remove() 方法1234567Dictionary.prototype.remove = function (key)&#123; if(this.has(key))&#123; delete this.items[key]; return true; &#125; return false;&#125;; get() 方法123Dictionary.prototype.get = function (key)&#123; return this.has(key) ? this.items[key] : undefined;&#125;; keys() 方法123Dictionary.prototype.keys = function ()&#123; return Object.keys(this.items);&#125;; values() 方法123456789Dictionary.prototype.values = function ()&#123; var values = []; for(var item in this.items)&#123; if(this.items.hasOwnProperty(item))&#123; values.push(this.items[item]); &#125; &#125; return values;&#125;; clear() 方法1234Dictionary.prototype.clear = function ()&#123; this.items = &#123;&#125;; return this;&#125;; size() 方法123Dictionary.prototype.size = function ()&#123; return Object.keys(this.items).length;&#125;; 小结以上就简单的实现了字典类，虽然简单，但是可以帮助我们更好的理解字典的概念和结构。 用心学习，加油！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合]]></title>
      <url>%2F2017%2F02%2F20%2F%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[集合的基本概念 集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，应用在计算机的数据结构中。 在深入学习集合的计算机科学实现之前，先来看看它在数学中的概念。在数学中，集合是一组不同对象的集。比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, ...}。集合中的对象列表用{}包围。 还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数（也就是质数）集合。由于24和29之间没有素数，这个集合就是空集。 说的再简单点，你大可以把集合想象成一个既没有重复元素，也没有固定顺序的数组。 在数学中，集合有并集、交集、差集等基本操作。在接下来我们会逐一使用JS来实现。 创建一个集合在ES6中，已经实现了Set类。我们接下来要实现的就是以它为基础的。以下是集合类的构造函数： 1234var Set = function ()&#123; this.items = &#123;&#125;; return this;&#125;; 有一个非常重要的细节，我们使用对象而不是数组来表示集合。当然也可以用数组实现。在JS中对象的键不允许同时指向两个不同的属性，这保证了集合里面的元素都是唯一的。 要实现集合类的一些方法： add(value) : 向集合中添加一个新项 remove(value) : 从集合中移除一个值 has(value) : 如果值在集合中，返回true，否则返回fasle clear() : 移除集合中所有项 size() : 返回集合所包含元素的数量 values() : 返回一个包含集合中所有key值的数组 has(value) 方法 首先要实现这个方法的目的是它需要被add() remove()等方法调用。 123Set.prototype.has = function (value)&#123; return value in this.items;&#125;; 除了in操作符可以判断给定的值是否是对象的属性之外，还有更好的实现方式： 123Set.prototype.has = function (value)&#123; return this.items.hasOwnProperty(value);&#125;; 所有的JS对象都有hasOwnProperty方法，这个方法用来判断当前属性是不是对象自身的属性（不包含原型链中的属性）。 add(key) 方法有了上面的基础，这个方法实现起来会非常简单： 1234567Set.prototype.add = function (value)&#123; if(!this.has(value))&#123; this.items[value] = value; return this; &#125; return false;&#125;; remove() 和 clear() 方法这两个方法也很简单，直接上代码： 1234567891011Set.prototype.remove = function (value)&#123; if(this.has(value))&#123; delete this.items[value]; return true; &#125; return false;&#125;;Set.prototype.clear = function ()&#123; this.items = &#123;&#125;; return this;&#125;; size() 方法实现size()的方法有很多。 第一种可以像链表类一样，设定个变量，添加一个让其自增一次。 第二种可以使用JS中内建的Object的一个内建函数(ECMAScript5以上版本)： 123Set.prototype.size = function ()&#123; return Object.keys(this.items).length;&#125;; Object.keys()用来返回对象中所有数组的集合，以数组的形式返回。 第三种可以手动提取每一个this.items的属性，然后记录个数： 123456789Set.prototype.size = function ()&#123; var count = 0; for(var key in this.items)&#123; if(this.items.hasOwnProperty(key))&#123; count++; &#125; &#125; return count;&#125;; 使用hasOwnProperty是很有必要的，可以防止在Ojbect上自定义的属性被遍历。 values() 方法values()方法也可以使用相同的逻辑，提取所有属性，并且以数组的形式返回 123Set.prototype.values = function ()&#123; return Object.keys(this.items);&#125;; 上述代码等价于下面这段代码： 1234567Set.prototype.values = function ()&#123; var keys = []; for(var key in this.items)&#123; keys.push(key); &#125; return keys;&#125;; 使用 Set 类1234567var s = new Set();s.add(1).add(2);console.log(s); console.log(s.values()); 集合的操作学了有关于集合的基本概念，接下来咱们一起来学习一下集合的相关操作。集合的操作主要包括4种，分别是： 并集：对于给定的两个集合，返回一个包含两个集合所有元素的新集合。 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合不存在于第二个集合的元素的新集合。 子集：验证给定集合是否是另一个集合的子集。 并集并集的数学概念，集合A和B的并集，标识为A∪B,下图展示了并集操作： 现在来实现Set类的union方法： 123456789101112Set.prototype.union = function (otherSet)&#123; var unionSet = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; unionSet.add(this.items[values[i]]); &#125; values = otherSet.values(); for(var i=0; i&lt;values.length; i++)&#123; unionSet.add(otherSet.items[values[i]]); &#125; return unionSet;&#125;; 测试以上方法： 12345var s1 = new Set();s1.add(1).add(2).add(3);var s2 = new Set().add(2).add(3).add(4);var s3 = s1.union(s2);console.log(s3); 交集交集的数学概念，集合A和B的交集，标识为A∪B，定义如下图： 实现Set类的intersection方法： 12345678910Set.prototype.intersection = function (otherSet)&#123; var intersectionSet = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(otherSet.has(values[i]))&#123; intersectionSet.add(this.items[values[i]]); &#125; &#125; return intersectionSet;&#125;; 测试以上方法： 12345var s1 = new Set();s1.add(1).add(2).add(3).add(function()&#123;&#125;);var s2 = new Set().add(2).add(3).add(4);var s3 = s1.intersection(s2);console.log(s3); 差集差集的数学概念，集合A和B的差集，表示为A-B，如下图： 现在来实现Set类的difference方法： 12345678910Set.prototype.difference = function (otherSet)&#123; var differenceSet = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(!otherSet.has(values[i]))&#123; differenceSet.add(this.items[values[i]]) &#125; &#125; return differenceSet;&#125;; 测试以上方法： 12345var s1 = new Set();s1.add(1).add(2).add(3).add(function()&#123;&#125;);var s2 = new Set().add(2).add(3).add(4);var s3 = s1.difference(s2);console.log(s3); 子集子集的数学概念，集合A是B的子集（或集合B包含了A）,表示A⊆B，如下图： 现在来实现Set类的isChildren方法： 123456789Set.prototype.isChildren = function (ohterSet)&#123; var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(!ohterSet.has(values[i]))&#123; return false; &#125; &#125; return true;&#125;; 测试以上代码： 12345var s1 = new Set();s1.add(1).add(2).add(3);var s2 = new Set().add(1).add(2).add(3).add(4);var s3 = s1.isChildren(s2);console.log(s3); // true 12345var s1 = new Set();s1.add(1).add(2).add(3);var s2 = new Set().add(1).add(2).add(4);var s3 = s1.isChildren(s2);console.log(s3); // false 总结集合类虽然是其它语言的数据结构，但是学习它，很有助于我们理解ES6的Set数据结构。 以下是完整的Set类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var Set = function ()&#123; this.items = &#123;&#125;; return this;&#125;;Set.prototype.has = function (value)&#123; return this.items.hasOwnProperty(value);&#125;;Set.prototype.add = function (value)&#123; if(this.has(value)) return false; this.items[value] = value; return this;&#125;;Set.prototype.remove = function (value)&#123; if(!this.has(value)) return false; delete this.items[value]; return true;&#125;;Set.prototype.clear = function ()&#123; this.items = &#123;&#125;; return this;&#125;;Set.prototype.size = function ()&#123; return Object.keys(this.items).length;&#125;;Set.prototype.values = function ()&#123; return Object.keys(this.items);&#125;;Set.prototype.union = function (otherSet)&#123; var unionSet = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; unionSet.add(this.items[values[i]]); &#125; values = otherSet.values(); for(var i=0; i&lt;values.length; i++)&#123; unionSet.add(otherSet.items[values[i]]); &#125; return unionSet;&#125;;Set.prototype.intersection = function (otherSet)&#123; var intersection = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(otherSet.has(values[i]))&#123; intersection.add(this.items[values[i]]); &#125; &#125; return intersection;&#125;;Set.prototype.difference = function (otherSet)&#123; var differenceSet = new Set(); var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(!otherSet.has(values[i]))&#123; differenceSet.add(this.items[values[i]]) &#125; &#125; return differenceSet;&#125;;Set.prototype.isChildren = function (ohterSet)&#123; var values = this.values(); for(var i=0; i&lt;values.length; i++)&#123; if(!ohterSet.has(values[i]))&#123; return false; &#125; &#125; return true;&#125;; 小结虽然我们的Set类跟ECMAScript6中的还有一定的区别，但是这已经可以使我们对Set类有更进一步的了解了，下一节我们将学习如何对集合进行操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[链表]]></title>
      <url>%2F2017%2F02%2F15%2F%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[链表的基本概念 链表是一种非常有趣的动态的数据结构，这意味这我们可以从中任意的添加或移除项，它会按需进行扩容。 在JS中要储存多个元素，数组或者列表可能是最常用的数据结构。但是这些数据结构也是有缺点的，从数组的起点或者中间插入或者删除元素的成本很高，因为需要移动元素（尽管JS内部已经实现了对数组项移动的相关操作，但其背后的情况仍然是这样的）。 链表储存有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续的。每个元素有一个储存本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。如下图： 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其它元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的元素，而想要访问链表中间的一个元素，需要从起点开始迭代列表直到找到所需要的元素。 拿到现实中最能体现链表的例子，那就是火车。一列火车是由一系列车厢组成的。每节车厢都是互相链接的。可以很容易分离一节车厢，改变它的位置，添加或者移除它。每一节车厢就好比链表中的每一个元素，中间的链接就好比指针。 接下来你将会学到：链表和双向链表。 创建一个链表接下来会创建一个Link类，并实现以下功能： append(ele): 向链表尾部添加一个新的项 removeAt(index): 从链表特定位置移除一项 get(index): 获取指定位置的值 set(index, value): 设置指定位置的值 indexOf(ele): 返回元素在链表中的索引，如果没找到返回-1 remove(ele): 从链表中移除一项 insert(index, ele): 向链表指定的位置插入一个新的项 isEmpyt(): 如果链表不包含任何元素返回true否则false size(): 返回链表包含元素的个数 toString(): 由于链表使用了Node类，需要重写JS的toString方法，让其只输出元素的指 getHead(): 返回链表的头部节点信息 构造函数如下： 12345function Link()&#123; this.head = null; this.length = 0; return this;&#125; 创建Node类的私有方法为了让Node类与链表本身更加紧密关联，在这里先实现一个可以创建Node类的私有方法，代码如下： 123456Link.prototype._node = function (element)&#123; var node = &#123;&#125;; node.element = element; node.next = null; return node;&#125;; 该方法每次调用都会返回一个新对象，里面包含要保存的值以及指向下一个节点的指针。 向链表尾部追加元素 在追加元素的时候分为两种情况：链表为空，添加的是第一个元素，或者不为空，向其追加。 123456789101112131415Link.prototype.append = function (ele)&#123; var node = this._node(ele); var current = null; if(this.head === null)&#123; this.head = node; &#125;else&#123; current = this.head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125; this.length++; return this;&#125;; 让我们来分析以下上面的代码：先是把要添加的元素作为参数传入，创建Node的实例。 场景一： 向空的链表添加一个元素。当我们创建Link对象时，this.head会指向null，这就意味着像链表中添加第一个元素。因此要做的事情就是让head元素指向当前这个Node对象。同时下一个this.next会自动指向null。 链表中最后一个节点的下一个始终指向的是null。 场景二：链表不为空。要向链表尾部添加元素，始终要记住一点就是首先需要找到最后一个元素，我们始终只有第一个元素的引用，因此循环访问链表，直到找到最后一项。为此，我们创建current这个中间量。当current.next === null的时候循环就会终止，这样就可以知道已经到达尾部了。之后要做的便是让最后一个元素的this.next指向要添加的元素。下图展示了这个行为： 12345var linked = new Link();linked.append(1).append(2).append(3);console.log(linked); 最后别忘了更新链表的长度。 从链表中移除元素 移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任意元素。 要实现的移除方法： 根据位置移除 ： removeAt(index) 根据元素的值移除 ： remove(element) 这一部分先来实现根据位置移除元素的方法： 12345678910111213141516171819202122232425Link.prototype.removeAt = function (index)&#123; if(index &lt; 0 || index &gt; this.length -1)&#123; return; &#125; var current = this.head, idx = 0, previous = null; if(index === 0)&#123; // 如果传入的是0那么就是移除第一个 // 简单的将head的指针修改即可 this.head = current.next; &#125;else&#123; // 如果不是0，那么想找到对应位置的元素，就要从头开始循环 // 原理就是找到对应的元素后，将对应元素的上一个元素的next指向当前元素的下一个元素 while(idx++ &lt; index)&#123; previous = current; current = current.next; &#125; // 这样循环结束之后 previous 储存的就是目标元素的上一个，而current储存的就是目标元素 // 之后将目标元素的上一个和目标元素的下一个相连 previous.next = current.next; &#125; // 更新长度; this.length--; // 返回删除元素的值 return current.element;&#125;; 让我们来进一步分析上面的代码：该方法首先来验证要移除元素的位置是否有效，如果无效九返回null，第一种场景如果是移除链表的第一个元素，就是让this.head指向链表的第二个元素，于是巧妙的利用了current这个中间变量。下图展示了移除第一个元素的过程，请好好理解： 第二种情况就是移除除了第一个元素意外的任意一个元素，先来看如果移除的是最后一个元素的情况，如图： 从图上可以清楚的看到，当移除的是最后一个元素的时候，在找到最后一个元素的上一个元素之后，将上一个的this.next引用到当前元素的下一个也就是this.next = null;。 再来看看，对于链表中其它的元素是否可以遵循同样的逻辑，如图： 可以看出来除了第一项其它的元素都遵循上面的逻辑。这里还值得说的是，当元素不再被任何变量引用，那么它占用的内存就会被垃圾回收机制释放掉。 获取指定位置的值接下来我们要来实现链表的get()方法，用来方便的通过索引来获取对应的值 1234567891011121314Link.prototype.get = function (index)&#123; if(index &lt; 0 || index &gt; this.length - 1)&#123; return null; &#125; var current = null, idx = 0; if(index === 0)&#123; return this.head.element; &#125; current = this.head; while(idx++ &lt; index)&#123; current = current.next; &#125; return current.element;&#125;; 设置指定位置的值下面来实现可以设置指定位置数据的set()方法： 12345678910111213141516Link.prototype.set = function (index, value)&#123; if(index &lt; 0 || index &gt; this.length - 1)&#123; return null; &#125; var current = null, idx = 0; if(index === 0)&#123; this.head.element = value; &#125;else&#123; current = this.head; while(idx++ &lt; index)&#123; current = current.next; &#125; current.element = value; &#125; return this;&#125;; 测试代码： 12345var nodeList = new Link(); nodeList.append(1).append(2).append(3);nodeList.set(0, 10);console.log(nodeList); 结果如图： 在任意位置插入一个元素 insert()方法可以实现在任意地方插入新元素。其原理就是找到要插入的位置的前后元素，然后将它们链接起来。 12345678910111213141516171819Link.prototype.insert = function (index, element)&#123; if(index &lt; 0 || index &gt;= this.length + 1)&#123; throw new Error(&apos;fuck!&apos;); &#125; var node = this._node(element), current = this.head, previous = null, idx = 0; if(index === 0)&#123; this.head = node; this.head.next = current; &#125;else&#123; while(idx++ &lt; index)&#123; previous = current; current = current.next; &#125; previous.next = node; node.next = current; &#125; this.length++; return this;&#125;; 有了前面的基础，我相信再看上面的代码应该会很容易了。同样分为两种场景，第一种是像最前面添加，第二种是向指定位置添加。来看图： 向最前面添加，只需要改变this.head的指向即可： 向任意位置添加，同样需要先找到对应位置的元素和这个元素的上一个元素，然后将新元素和它们链接起来即可： 向最后一个位置插入元素： 向中间任意位置插入元素： 实现其他方法 接下来将实现：toString() indexOf() isEmpty() size()等Link类的方法。 toString()方法会把Link对象转换成一个字符串 123456789Link.prototype.toString = function ()&#123; var current = this.head, string = &apos;&apos;; while(current)&#123; string += &apos;,&apos; + current.element; current = current.next; &#125; return string.slice(1);&#125;; indexOf()方法接收一个元素的值，如果在链表中找到它就返回它的位置，否则就返回-1 123456789101112Link.prototype.indexOf = function (element)&#123; var current = this.head, index = -1; while(current)&#123; index++; if(element === current.element)&#123; return index; &#125; current = current.next; &#125; return -1;&#125;; 有了这个方法就可以很容易的实现上面还没完成的remove()方法了： 1234Link.prototype.remove = function (element)&#123; var index = this.indexOf(element); return this.removeAt(index);&#125;; isEment() size() getHead()三个方法相对比较简单，这里一次性写完 1234567891011Link.prototype.isEmpty = function ()&#123; return this.length === 0;&#125;;Link.prototype.size = function ()&#123; return this.length;&#125;;Link.prototype.getHead = function ()&#123; return this.head;&#125;; 双向链表双向链表和普通链表的区别在于，一个元素不仅仅只有链向下一个节点的链接，而在双向链表中，链接是双向的，一个链向下一个元素，另一个链向上一个元素，如下图所示： 只需要在单项链表构造函数的基础上稍加改动即可实现： 123456function DoubleLink()&#123; this.head = null; this.tail = null; // 用来存放最后一个节点 this.length = 0; return this;&#125; 双向链表提供了两种迭代的方法：从头到尾或者反过来。同时还可以访问任意一个元素的上一个和下一个兄弟元素。这是双向链表的一个优点。 双向链表的Node类按照需求，需要对Node类进行修改，添加一个指向上一个节点的指针，如下： 123456DoubleLink.prototype._node = function (element)&#123; this.element = element; this.prev = null; this.next = null; return this;&#125;; 在任意位置插入一个新元素在双向链表中插入一个新元素跟单向链表非常类似。但是双向链表需要同时控制this.next和this.prev两个指针。 1234567891011121314151617181920212223242526272829303132DoubleLink.prototype.insert = function (index, element)&#123; if(index &lt; 0 || index &gt; this.length)&#123; throw new Error(&apos;fuck!&apos;); &#125; var count = 0, current = this.head, previous = null, node = this._node(element); if(index === 0)&#123; if(this.head)&#123; node.next = current; current.prev = node; this.head = node; &#125;else&#123; this.head = this.tail = node; &#125; &#125;else if(index === this.length)&#123; current = this.tail; current.next = node; node.prev = current; this.tail = node; &#125;else&#123; while(count++ &lt; index)&#123; previous = current; current = current.next; &#125; previous.next = node; node.prev = previous; node.next = current; current.prev = node; &#125; this.length++; return this;&#125;; 通过示意图来分析上面的代码 第一种场景，向最前面添加元素，分为第一次添加和已经有第一个元素的两种情况。 第二种场景，向链表最后添加新元素。 第三种场景，向链表中间的位置添加新元素。 从任意位置移除元素从双向链表中移除元素跟单向链表非常类似。唯一区别就是需要设置前一个位置的指针。 123456789101112131415161718192021222324252627DoubleLink.prototype.removeAt = function (index)&#123; if(index &lt; 0 || index &gt; this.length - 1)&#123; return; &#125; var current = this.head, previous = null, count = 0; if(index === 0)&#123; this.head = current.next; if(this.length === 1)&#123; this.tail = null; &#125;else&#123; this.head.prev = null; &#125; &#125;else if(index === this.length - 1)&#123; current = this.tail; this.tail = current.prev; this.tail.next = null; &#125;else&#123; while(count++ &lt; index)&#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next.prev = previous; &#125; this.length--; return current.element;&#125; 移除元素同样分为三种场景：从头部，从中间，从尾部；依然使用示意图来说明。 移除第一个元素的过程： 移除最后一个元素的过程： 移除中间元素的过程： 其它方法和单项链表非常类似，这里就不一一去实现了。 循环链表学了上面的链表相关的知识，再来看循环链表会变得相当简单。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针不是null，而是指向第一个元素this.head，如下图所示： 单项循环链表示意图： 双向链表循环示意图： 这里暂且不对循环列表再进行coding，我相信如果上面的你学会了，那么很容易就能实现循环链表。 小结链表的优点在于无需移动所有元素就可以方便的删除和添加元素。但是就JavaScript开发本身而言，我个人并不会去刻意的使用，或许我还没意识到这些数据结构的重要性吧。 路还长着，且学且珍惜！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[列队]]></title>
      <url>%2F2017%2F02%2F10%2F%E5%88%97%E9%98%9F%2F</url>
      <content type="text"><![CDATA[队列的基本概念队列和栈非常类似，但是不同的是队列遵循的是FIFO(first in first out)，也称为先来先服务，队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队尾。在现实中最常见的队列就是排队。 类似的还有去电影院买票，杂货店收银台，自助餐厅等，我们都会去排队，排在第一位的人会先接受服务。 创建队列要实现的队列类具有的基本方法： enqueue(eles): 向队列尾部添加元素 dequeue(): 移除队列的第一项，并返回这个元素 front(): 返回队列中的第一个元素，不对队列做任何其它处理 isEmpty(): 如果队列不包含任何元素返回true，否则返回false size(): 返回队列中包含元素的个数 12345678910111213141516171819202122232425var Queue = function ()&#123; this.items = []; return this;&#125;;Queue.prototype.enqueue = function ()&#123; [].push.apply(this.items, arguments); return this.items.length;&#125;;Queue.prototype.dequeue = function ()&#123; return this.items.shift();&#125;;Queue.prototype.front = function ()&#123; return this.items[0];&#125;;Queue.prototype.isEmpty = function ()&#123; return this.items.length == 0;&#125;;Queue.prototype.size = function ()&#123; return this.items.length;&#125;; 小应用：击鼓传花在击鼓传花的游戏中，孩子们围成一圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出结束游戏。重复这个过程，直到只剩下一个孩子（胜者）。 123456789101112131415161718192021222324252627282930function hotPotato(list, num)&#123; var queue = new Queue(); for(var i=0; i&lt;list.length; i++)&#123; queue.enqueue(list[i]); &#125; var temp = &apos;&apos;; while(queue.size()&gt;1)&#123; for(var i=0; i&lt;num; i++)&#123; queue.enqueue(queue.dequeue()); &#125; temp = queue.dequeue(); console.log(temp + &apos;在击鼓传花中被淘汰！&apos;); &#125; return queue.dequeue();&#125;var names = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];var winner = hotPotato(names, 7);console.log(&apos;胜利者是:&apos; + winner);/* b在击鼓传花中被淘汰！ e在击鼓传花中被淘汰！ d在击鼓传花中被淘汰！ a在击鼓传花中被淘汰！ f在击鼓传花中被淘汰！ 胜利者是:c*/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈]]></title>
      <url>%2F2017%2F02%2F05%2F%E6%A0%88%2F</url>
      <content type="text"><![CDATA[栈的基本概念 栈是一种遵循后进先出(LIFO)原则的有序集合，新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫做栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。 在生活中有很多类似的这种结构的模型，例如一摞书或者餐厅里堆放的盘子。 模拟Stack类用JS来模拟一个栈的类，具有如下方法： push(ele): 向栈中添加要给元素 pop(): 删除并返回栈顶的元素 peek(): 返回栈顶的元素 isEmpty(): 如果栈里没有任何元素就返回true，否则就返回false clear(): 清空栈 size(): 返回栈里的元素个数 print(): 将栈中的元素转为字符串并打印出来 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function Stack()&#123; this.items = []; return this; &#125; Stack.prototype.push = function (ele) &#123; this.items.push(ele); return this; &#125;; Stack.prototype.pop = function () &#123; return this.items.pop(); &#125;; Stack.prototype.peek = function () &#123; return this.items[this.items.length - 1]; &#125;; Stack.prototype.isEmpty = function () &#123; return this.items.length == 0; &#125;; Stack.prototype.clear = function () &#123; this.items = []; return this; &#125;; Stack.prototype.size = function () &#123; return this.items.length; &#125;; Stack.prototype.print = function () &#123; console.log(this.items.toString()); return this; &#125;; var stack = new Stack(); stack.push(1); stack.clear(); stack.push(&apos;a&apos;); stack.pop(); stack.push(100); console.log(stack.peek()); console.log(stack.size()); console.log(stack.isEmpty());&lt;/script&gt; 下图描绘了对栈中的元素进行添加和删除操作的过程： 利用Stack类解决一些问题 在现实生活中，我们习惯于使用十进制，但是在计算机科学中，二进制非常重要，因为计算机的所有数据都是用二进制即0和1表示的。如果没有十进制和二进制的转化能力，与计算机进行交流将会变得很难。要把十进制转化为二进制，可以将十进制数字和2进行整除（二进制是满2进1），直到结果是0为止。 下图表示十进制转化二进制的过程: 以10为例，转化为2进制： 下面是对应的算法： 1234567891011121314function num2Base(num, base)&#123; var remStack = new Stack(), rem, res = &apos;&apos;, digit = &apos;0123456789ABCDEF&apos;; while(num &gt; 0)&#123; rem = Math.floor(num % base); remStack.push(rem); num = Math.floor(num / base); &#125; while(!remStack.isEmpty())&#123; res += digit[remStack.pop()]; &#125; return res;&#125; 使用测试： 123console.log(num2Base(10, 2)); // 1010console.log(num2Base(15, 8)); // 17console.log(num2Base(332, 16)); // 14C]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年，注定不平凡]]></title>
      <url>%2F2017%2F01%2F28%2F2017%E5%B9%B4%EF%BC%8C%E6%B3%A8%E5%AE%9A%E4%B8%8D%E5%B9%B3%E5%87%A1%2F</url>
      <content type="text"><![CDATA[记得抬头仰望星空，在这个宇宙中总有那么一些事，你能做成，并且能做的很好！]]></content>
    </entry>

    
  
  
</search>
